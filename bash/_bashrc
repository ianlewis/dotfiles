#!/usr/bin/env bash
# vim: set ft=bash:
#
# Copyright 2024 Ian Lewis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# _bashrc_setup_homebrew initializes the Homebrew environment on macOS.
function _bashrc_setup_homebrew() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        local hb_prefix
        hb_prefix="/opt/homebrew"

        # Enable homebrew if present
        if [ -x "${hb_prefix}/bin/brew" ]; then
            eval "$(${hb_prefix}/bin/brew shellenv)"
        fi
    fi
}

# _bashrc_setup_bash_completion sets up bash completion if available. On macOS
# it first attempts to load the system wide bash completion provided by the
# Homebrew bash-completion package. If that is not available it falls back to
# loading the local ~/.bash_completion file. On Linux it attempts to load the
# system wide /etc/bash_completion file first before falling back to the local
# ~/.bash_completion file.
function _bashrc_setup_bash_completion() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # Load the system wide bash completion if available.
        # The system wide config should load our local config.
        # shellcheck source=/dev/null
        if [[ -r "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh" ]] && ! shopt -oq posix; then
            # shellcheck source=/dev/null
            . "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh"
        elif [ -r "${HOME}/.bash_completion" ]; then
            # The system wide config is not available so just load our completion
            # shellcheck source=/dev/null
            source "${HOME}/.bash_completion"
        fi
    else
        # Load the system wide bash completion if available.
        if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
            # The system wide config should load our local config.
            # shellcheck source=/dev/null
            source /etc/bash_completion
        elif [ -r "${HOME}/.bash_completion" ]; then
            # The system wide config is not available so just load our completion
            # shellcheck source=/dev/null
            source "${HOME}/.bash_completion"
        fi
    fi
}

function _bashrc_main() {
    XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
    export XDG_DATA_HOME

    if [ -r "${HOME}/.bashrc_init_local" ]; then
        # shellcheck source=/dev/null
        source "${HOME}/.bashrc_init_local"
    fi

    # tmux
    # Start a tmux session if not already in one
    # Exit directly after the tmux session is exited
    # Only run if logged in remotely via ssh
    if shopt -q login_shell; then
        # Only run if running in a terminal.
        if [[ (-t 1) && (${TERM} != screen*) && -z ${TMUX} ]]; then
            if command -v tmux >/dev/null 2>&1; then
                # Attempt to discover a detached session
                # Use the current username as the session name.
                if tmux has-session -t "${USER}" 2>/dev/null; then
                    exec tmux attach-session -t "${USER}"
                else
                    exec tmux new-session -s "${USER}"
                fi
            fi
        else
            # If in a tmux/screen session print the motd.
            if [ -r "/etc/motd" ]; then
                cat /etc/motd
            elif [ -r "/var/run/motd" ]; then
                cat /var/run/motd
            elif [ -r "/var/run/motd.dynamic" ]; then
                cat /var/run/motd.dynamic
            fi
        fi
    fi

    # If not running interactively, don't do anything. PS1 may be unbound so we
    # need to use a special form of parameter expansion.
    [ -z "${PS1+x}" ] && return

    # Load system bashrc
    # NOTE: On Debian based systems /etc/bash.bashrc is loaded before ~/.bashrc
    #       `-DSYS_BASHRC` compile-time option and does not need to be sourced here.
    if [ -r /etc/bashrc ]; then
        # shellcheck source=/dev/null
        source /etc/bashrc
    fi

    EDITOR=vim
    if command -v nvim >/dev/null 2>&1; then
        EDITOR=nvim
    fi
    VISUAL=${EDITOR}

    export EDITOR
    export VISUAL

    if [ "$(uname)" == "Darwin" ]; then
        # Enable colors on Mac OSX Terminal
        export CLICOLOR=1
        export LSCOLORS=ExGxFxDxCxHxHxCbCeEbEb
    else
        # Enable colors on linux
        eval "$(dircolors -b)"
    fi

    # Create the ~/opt directory.
    mkdir -p "${HOME}/opt"

    # Create vim swap file directory
    if [ ! -d "${HOME}/.vimswp" ]; then
        mkdir -p "${HOME}/.vim/swap"
    fi
    if [ ! -d "${HOME}/.vim/backup" ]; then
        mkdir -p "${HOME}/.vim/backup"
    fi

    # don't put duplicate lines in the history. See bash(1) for more options
    export HISTCONTROL=ignoredups
    # ... and ignore same sucessive entries.
    export HISTCONTROL=ignoreboth

    # check the window size after each command and, if necessary,
    # update the values of LINES and COLUMNS.
    shopt -s checkwinsize

    # make less more friendly for non-text input files, see lesspipe(1)
    [ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"

    # less should never use the bell and not paginate if less than one page.
    export LESS="qR -F -X ${LESS}"
    export LESS

    # Set the bat theme.
    export BAT_THEME="tokyonight_moon"

    local bash_lib_dir="${HOME}/.local/share/bash/lib"
    local nvim_plugin_dir="${HOME}/.config/nvim/pack/nvim/start"

    # Simple Bash Prompt
    # shellcheck source=/dev/null
    SBP_PATH="${bash_lib_dir}/sbp"
    if [[ -r "${SBP_PATH}/sbp.bash" ]]; then
        # shellcheck source=/dev/null
        source "${SBP_PATH}/sbp.bash"
    fi
    export SBP_PATH

    # fzf Theme.
    # shellcheck source=/dev/null
    local moon_theme_path="${nvim_plugin_dir}/tokyonight.nvim/extras/fzf/tokyonight_moon.sh"
    if [[ -r ${moon_theme_path} ]]; then
        # shellcheck source=/dev/null
        source "${moon_theme_path}"
    fi

    # Set and export gpg tty
    GPG_TTY=$(tty)
    export GPG_TTY

    # ssh-agent
    # Start an ssh-agent instance if an existing one isn't found.
    mkdir -p "${HOME}/.ssh"
    if [[ -z ${SSH_AUTH_SOCK} ]] && [[ -r "${bash_lib_dir}/ssh-find-agent/ssh-find-agent.sh" ]]; then
        # ssh-find-agent assumes that ~/.ssh/authorized_keys exists
        if [ ! -f "${HOME}/.ssh/authorized_keys" ]; then
            touch "${HOME}/.ssh/authorized_keys"
        fi
        # shellcheck source=/dev/null
        source "${bash_lib_dir}/ssh-find-agent/ssh-find-agent.sh"

        ssh_find_agent -a || eval "$(ssh-agent -s)" >/dev/null
    fi

    # Alias definitions.
    if [ -r "${HOME}/.bash_aliases" ]; then
        # shellcheck source=/dev/null
        source "${HOME}/.bash_aliases"
    fi

    # Setup homebrew on macOS
    _bashrc_setup_homebrew

    # Go
    GOPATH=${HOME}/go
    GOBIN=${GOPATH}/bin
    [[ ":$PATH:" != *":${GOBIN}:"* ]] && PATH="${GOBIN}:${PATH}"
    export GOPATH
    export GOBIN
    if [ -d "${HOME}/opt/go" ]; then
        GOROOT=${HOME}/opt/go
        [[ ":$PATH:" != *":${GOROOT}/bin:"* ]] && PATH="${GOROOT}/bin:${PATH}"
        export GOROOT
    fi

    # Python
    export PYENV_ROOT="${XDG_DATA_HOME}/pyenv"
    if [[ -d "${PYENV_ROOT}/bin" ]]; then
        [[ ":$PATH:" != *":${PYENV_ROOT}/bin:"* ]] && PATH="${PYENV_ROOT}/bin:${PATH}"
        eval "$(pyenv init - bash)"
    fi

    # Activate the user's virtualenv if it exists.
    if [[ ${VIRTUAL_ENV##*/} != "${USER}" ]] && [[ -r "${PYENV_ROOT}/versions/${USER}/bin/activate" ]]; then
        pyenv activate "${USER}"
    fi

    # Nodenv
    export NODENV_ROOT="${XDG_DATA_HOME}/nodenv"
    if [[ -d "${NODENV_ROOT}/bin" ]]; then
        [[ ":$PATH:" != *":${NODENV_ROOT}/bin:"* ]] && PATH="${NODENV_ROOT}/bin:${PATH}"
        eval "$(nodenv init - bash)"
    fi

    # Activate the local node_modules.
    if [[ -d "${XDG_DATA_HOME}/node_modules/.bin" ]]; then
        [[ ":$PATH:" != *":${XDG_DATA_HOME}/node_modules/.bin:"* ]] && PATH="${XDG_DATA_HOME}/node_modules/.bin:${PATH}"
    fi

    # Rbenv
    export RBENV_ROOT="${XDG_DATA_HOME}/rbenv"
    if [[ -d "${RBENV_ROOT}/bin" ]]; then
        [[ ":$PATH:" != *":${RBENV_ROOT}/bin:"* ]] && PATH="${RBENV_ROOT}/bin:${PATH}"
        eval "$(rbenv init - bash)"
    fi

    # Rust
    if [[ -r "${HOME}/.cargo/env" ]]; then
        # shellcheck source=/dev/null
        source "${HOME}/.cargo/env"
    fi

    # The .local/bin is used for some local installs such as applications
    # installed via 'pip install --user'
    [[ ":$PATH:" != *":${HOME}/.local/bin:"* ]] && PATH="${HOME}/.local/bin:${PATH}"

    # Aqua. We want aqua to be able to override other global paths so it gets
    # highest priority.
    if command -v aqua >/dev/null 2>&1; then
        aqua_root="$(aqua root-dir)"
        [[ ":$PATH:" != *":${aqua_root}/bin:"* ]] && PATH="${aqua_root}/bin:${PATH}"
    fi

    # Local settings.
    if [[ -r "${HOME}/.bashrc.local" ]]; then
        # shellcheck source=/dev/null
        source "${HOME}/.bashrc.local"
    fi

    export PATH

    # Setup bash completion
    _bashrc_setup_bash_completion

    # Print the message if reboot is required.
    if [[ -r /var/run/reboot-required ]]; then
        # Print the message if the file exists
        cat /var/run/reboot-required
    fi

    # Source the Google cloud devshell bashrc
    if [[ -r "/google/devshell/bashrc.google" ]]; then
        # shellcheck source=/dev/null
        source "/google/devshell/bashrc.google"
    fi
}

_bashrc_main

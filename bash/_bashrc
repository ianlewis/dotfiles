#!/usr/bin/env bash
# vim: set ft=bash:
#
# Copyright 2024 Ian Lewis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# ~/.bashrc: executed by bash(1) for interactive non-login shells.
#
# See /usr/share/doc/bash/examples/startup-files (bash-doc package) or read
# https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html
# for more information.

# NOTE: Though this file does not set `nounset` (set -u) itself, it is sourced
#       with `nounset` set in tests.

# _bashrc_setup_homebrew initializes the Homebrew environment on macOS.
function _bashrc_setup_homebrew() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        local hb_prefix
        hb_prefix="/opt/homebrew"

        # Enable homebrew if present
        if [ -x "${hb_prefix}/bin/brew" ]; then
            eval "$(${hb_prefix}/bin/brew shellenv)"
        fi
    fi
}

# _bashrc_setup_go sets up the Go environment.
function _bashrc_setup_go() {
    # Go
    GOPATH=${HOME}/go
    GOBIN=${GOPATH}/bin
    if [[ ":$PATH:" != *":${GOBIN}:"* ]]; then
        PATH="${GOBIN}:${PATH}"
    fi
    export GOPATH
    export GOBIN
    if [ -d "${HOME}/opt/go" ]; then
        GOROOT=${HOME}/opt/go
        if [[ ":$PATH:" != *":${GOROOT}/bin:"* ]]; then
            PATH="${GOROOT}/bin:${PATH}"
        fi
        export GOROOT
    fi
}

# _bashrc_setup_pyenv sets up pyenv if available.
function _bashrc_setup_pyenv() {
    export PYENV_ROOT="${XDG_DATA_HOME}/pyenv"
    # Python
    if [[ -d "${PYENV_ROOT}/bin" ]]; then
        if [[ ":$PATH:" != *":${PYENV_ROOT}/bin:"* ]]; then
            PATH="${PYENV_ROOT}/bin:${PATH}"
        fi
        eval "$(pyenv init - bash)"

        local virtual_env
        virtual_env="${VIRTUAL_ENV:-""}"
        # Activate the user's virtualenv if it exists.
        if [[ ${virtual_env##*/} != "${USER}" ]] && [[ -r "${PYENV_ROOT}/versions/${USER}/bin/activate" ]]; then
            # NOTE: pyenv activate will set PS1 for non-interactive shells.
            pyenv activate "${USER}"
        fi
    fi
}

# _bashrc_setup_nodenv sets up nodenv if available.
function _bashrc_setup_nodenv() {
    # Nodenv
    export NODENV_ROOT="${XDG_DATA_HOME}/nodenv"
    if [[ -d "${NODENV_ROOT}/bin" ]]; then
        if [[ ":$PATH:" != *":${NODENV_ROOT}/bin:"* ]]; then
            PATH="${NODENV_ROOT}/bin:${PATH}"
        fi
        eval "$(nodenv init - bash)"
    fi

    # Activate the local node_modules.
    if [[ -d "${XDG_DATA_HOME}/node_modules/.bin" ]]; then
        if [[ ":$PATH:" != *":${XDG_DATA_HOME}/node_modules/.bin:"* ]]; then
            PATH="${XDG_DATA_HOME}/node_modules/.bin:${PATH}"
        fi
    fi
}

# _bashrc_setup_rbenv sets up rbenv if available.
function _bashrc_setup_rbenv() {
    # Rbenv
    export RBENV_ROOT="${XDG_DATA_HOME}/rbenv"
    if [[ -d "${RBENV_ROOT}/bin" ]]; then
        if [[ ":$PATH:" != *":${RBENV_ROOT}/bin:"* ]]; then
            PATH="${RBENV_ROOT}/bin:${PATH}"
        fi
        eval "$(rbenv init - bash)"
    fi
}

# _bashrc_setup_rust sets up the Rust environment if available.
function _bashrc_setup_rust() {
    # Rust
    if [[ -r "${HOME}/.cargo/env" ]]; then
        # shellcheck source=/dev/null
        source "${HOME}/.cargo/env"
    fi
}

function _bashrc_setup_aqua() {
    if command -v aqua >/dev/null 2>&1; then
        aqua_root="$(aqua root-dir)"
        if [[ ":$PATH:" != *":${aqua_root}/bin:"* ]]; then
            PATH="${aqua_root}/bin:${PATH}"
        fi
    fi
}

# _bashrc_setup_aliases sources the ~/.bash_aliases file if it exists.
function _bashrc_setup_aliases() {
    # Alias definitions.
    if [ -r "${HOME}/.bash_aliases" ]; then
        # shellcheck source=/dev/null
        source "${HOME}/.bash_aliases"
    fi
}

# _bashrc_setup_bash_completion sets up bash completion if available. On macOS
# it first attempts to load the system wide bash completion provided by the
# Homebrew bash-completion package. If that is not available it falls back to
# loading the local ~/.bash_completion file. On Linux it attempts to load the
# system wide /etc/bash_completion file first before falling back to the local
# ~/.bash_completion file.
function _bashrc_setup_bash_completion() {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # Load the system wide bash completion if available.
        # The system wide config should load our local config.
        # shellcheck source=/dev/null
        if [[ -r "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh" ]] && ! shopt -oq posix; then
            # shellcheck source=/dev/null
            . "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh"
        elif [ -r "${HOME}/.bash_completion" ]; then
            # The system wide config is not available so just load our completion
            # shellcheck source=/dev/null
            source "${HOME}/.bash_completion"
        fi
    else
        # Load the system wide bash completion if available.
        if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
            # The system wide config should load our local config.
            # shellcheck source=/dev/null
            source /etc/bash_completion
        elif [ -r "${HOME}/.bash_completion" ]; then
            # The system wide config is not available so just load our completion
            # shellcheck source=/dev/null
            source "${HOME}/.bash_completion"
        fi
    fi
}

# _bashrc_update_path updates the PATH environment variable to include
# various language version managers and local bin directories.
function _bashrc_update_path() {
    _bashrc_setup_homebrew

    _bashrc_setup_go

    _bashrc_setup_pyenv

    _bashrc_setup_nodenv

    _bashrc_setup_rbenv

    _bashrc_setup_rust

    # The .local/bin is used for some local installs such as applications
    # installed via 'pip install --user'
    if [[ ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
        PATH="${HOME}/.local/bin:${PATH}"
    fi

    # Add krew bin path.
    if [[ ":$PATH:" != *":${HOME}/.krew/bin:"* ]]; then
        PATH="${HOME}/.krew/bin:${PATH}"
    fi

    # Aqua. We want aqua to be able to override other global paths so it gets
    # highest priority.
    _bashrc_setup_aqua
}

# _bashrc_source_local sources the ~/.bashrc.local file if it exists.
function _bashrc_source_local() {
    # Local settings.
    if [[ -r "${HOME}/.bashrc.local" ]]; then
        # shellcheck source=/dev/null
        source "${HOME}/.bashrc.local"
    fi
}

function _bashrc_main() {
    XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
    export XDG_CACHE_HOME
    XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
    export XDG_CONFIG_HOME
    XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
    export XDG_DATA_HOME
    XDG_STATE_HOME="${XDG_STATE_HOME:-${HOME}/.local/state}"
    export XDG_STATE_HOME

    if [[ -r "${HOME}/.bashrc_init_local" ]]; then
        # shellcheck source=/dev/null
        source "${HOME}/.bashrc_init_local"
    fi

    # If not running interactively, then return early.
    # NOTE: PS1 and tty may be set even for non-interactive shells so we check
    #       the special parameter $- for the presence of 'i'.
    if [[ ! $- =~ i ]]; then
        # Update the PATH even for non-interactive shells.
        _bashrc_update_path

        _bashrc_source_local

        export PATH

        return 0
    fi

    # tmux
    # Start a tmux session if not already in one
    # Exit directly after the tmux session is exited
    if shopt -q login_shell; then
        # Only run if running in a terminal.
        if [[ (-t 1) && (${TERM} != screen*) && -z ${TMUX} ]]; then
            if command -v tmux >/dev/null 2>&1; then
                # Attempt to discover a detached session
                # Use the current username as the session name.
                if tmux has-session -t "${USER}" 2>/dev/null; then
                    exec tmux attach-session -t "${USER}"
                else
                    exec tmux new-session -s "${USER}"
                fi
            fi
        else
            # If in a tmux/screen session print the motd.
            if [ -r "/etc/motd" ]; then
                cat /etc/motd
            elif [ -r "/var/run/motd" ]; then
                cat /var/run/motd
            elif [ -r "/var/run/motd.dynamic" ]; then
                cat /var/run/motd.dynamic
            fi
        fi
    fi

    # Load system bashrc
    # NOTE: On Debian based systems /etc/bash.bashrc is loaded before ~/.bashrc
    #       `-DSYS_BASHRC` compile-time option and does not need to be sourced here.
    if [ -r /etc/bashrc ]; then
        # shellcheck source=/dev/null
        source /etc/bashrc
    fi

    EDITOR=vim
    if command -v nvim >/dev/null 2>&1; then
        EDITOR=nvim
    fi
    VISUAL=${EDITOR}

    export EDITOR
    export VISUAL

    if [ "$(uname)" == "Darwin" ]; then
        # Enable colors on Mac OSX Terminal
        export CLICOLOR=1
        export LSCOLORS=ExGxFxDxCxHxHxCbCeEbEb
    else
        # Enable colors on linux
        eval "$(dircolors -b)"
    fi

    # don't put duplicate lines in the history. See bash(1) for more options
    export HISTCONTROL=ignoredups
    # ... and ignore same sucessive entries.
    export HISTCONTROL=ignoreboth

    # check the window size after each command and, if necessary,
    # update the values of LINES and COLUMNS.
    shopt -s checkwinsize

    # make less more friendly for non-text input files, see lesspipe(1)
    if command -v lesspipe >/dev/null 2>&1; then
        eval "$(lesspipe)"
    fi

    # less should never use the bell and not paginate if less than one page.
    export LESS="qR -F -X ${LESS}"
    export LESS

    # Set the bat theme.
    export BAT_THEME="tokyonight_moon"

    local bash_lib_dir="${XDG_DATA_HOME}/bash/lib"
    local nvim_plugin_dir="${XDG_CONFIG_HOME}/nvim/pack/nvim/start"

    # Simple Bash Prompt
    # shellcheck source=/dev/null
    SBP_PATH="${bash_lib_dir}/sbp"
    if [[ -r "${SBP_PATH}/sbp.bash" ]]; then
        # shellcheck source=/dev/null
        source "${SBP_PATH}/sbp.bash"
    fi
    export SBP_PATH

    # fzf Theme.
    # shellcheck source=/dev/null
    local moon_theme_path="${nvim_plugin_dir}/tokyonight.nvim/extras/fzf/tokyonight_moon.sh"
    if [[ -r ${moon_theme_path} ]]; then
        # shellcheck source=/dev/null
        source "${moon_theme_path}"
    fi

    # Set and export gpg tty
    GPG_TTY=$(tty)
    export GPG_TTY

    # ssh-agent
    # Start an ssh-agent instance if an existing one isn't found.
    mkdir -p "${HOME}/.ssh"
    if [[ -z ${SSH_AUTH_SOCK} ]] && [[ -r "${bash_lib_dir}/ssh-find-agent/ssh-find-agent.sh" ]]; then
        # NOTE: ssh-find-agent assumes that ~/.ssh/authorized_keys exists
        if [ ! -f "${HOME}/.ssh/authorized_keys" ]; then
            touch "${HOME}/.ssh/authorized_keys"
        fi
        # shellcheck source=/dev/null
        source "${bash_lib_dir}/ssh-find-agent/ssh-find-agent.sh"

        ssh_find_agent -a || eval "$(ssh-agent -s)" >/dev/null
    fi

    # Set a default crictl config path to squelch warnings but defer to the
    # system wide config if it exists.
    if [[ ! -r "/etc/crictl.yaml" ]]; then
        export CRI_CONFIG_FILE="${XDG_CONFIG_HOME}/crictl/crictl.yaml"
    fi

    # Update the PATH
    _bashrc_update_path

    # Source local settings
    _bashrc_source_local

    export PATH

    # Setup bash aliases
    _bashrc_setup_aliases

    # Setup bash completion
    _bashrc_setup_bash_completion

    # Print the message if reboot is required.
    if [[ -r /var/run/reboot-required ]]; then
        # Print the message if the file exists
        cat /var/run/reboot-required
    fi

    # Source the Google cloud devshell bashrc
    if [[ -r "/google/devshell/bashrc.google" ]]; then
        # shellcheck source=/dev/null
        source "/google/devshell/bashrc.google"
    fi
}

_bashrc_main
